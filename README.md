Висновки щодо аналізу алгоритмів сортування

Опис завдання

Було реалізовано три алгоритми сортування:

Сортування злиттям (Merge Sort)

Сортування вставками (Insertion Sort)

Timsort (вбудований sorted() у Python)

Ці алгоритми було протестовано на випадкових масивах різного розміру (1000, 5000, 10000 елементів) та заміряно їх час виконання.

Аналіз результатів

1. Сортування злиттям (Merge Sort)

Часова складність: O(n log n)

Працює добре на великих наборах даних.

Витрачає додаткову пам'ять через рекурсію.

У тестах показав стабільний час виконання.

2. Сортування вставками (Insertion Sort)

Часова складність: O(n²) у найгіршому випадку.

Ефективний для малих наборів даних або майже відсортованих масивів.

На великих масивах працює повільно через квадратичну складність.

3. Timsort (sorted())

Часова складність: O(n log n) (у середньому).

Поєднує сортування злиттям та сортування вставками.

Найшвидший алгоритм серед протестованих, оскільки оптимізований для реальних даних.

Висновки

Сортування злиттям добре підходить для великих наборів даних, але споживає більше пам'яті через рекурсію.

Сортування вставками є неефективним для великих випадкових масивів, але може бути корисним для невеликих масивів.

Timsort (вбудований sorted()) є найкращим вибором, оскільки працює швидше за всі інші алгоритми завдяки оптимізованому підходу.

Загалом, для більшості практичних випадків у Python рекомендується використовувати sorted() (Timsort), оскільки він оптимізований для різних типів вхідних даних.

